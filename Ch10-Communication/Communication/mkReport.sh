#!/bin/sh

# First we run simulations with different scanarios as defined in the testbench:
tbinf=CommunicationTestbench.vhd
tbsimf=CommunicationTestbench-sim.vhd
vcdf=CommunicationTestbench-sim.vcd
wavef=CommunicationTestbench-sim.ghw
tbentity=com_tb

workingDir=WorkingDirectory
tablef=CommunicationPerformanceTable.tex

doReport="No"
doClean="No"
doAccumulateReport="No"

archs=""
allArchVersions="SynchronousHandshake AsynchronousHandshake SynchronousFIFO AsynchronousFIFO"

scenarios="A"
allScenarios="A B C D E"

receiverClocks=10

USAGE="`basename $0` [-hcra] [ -S SCENARIO ] [ -C RCVCLOCK] ARCH1 ARCH2 ... \n\
     \t Simulate communciation architectures and scenarios and prepare reports. \n\
     \t     The possible archtectures are $allArchVersions.\n\
     \t -S SCEN: comma sperated list of scenarios. \n\
     \t\t    Possible scenarios are $allScenarios.\n\
     \t -r generate the report files. \n\
     \t -C CLKS: comma separated list of half periods for receiver clocks \n\
     \t\t    in the format \"cl1,cl2,...\". \n\
     \t -a acummulate: add the new results to the previously generated report.\n\
     \t\t    The default is to overwrite the previous report.
     \t -c clean: remove generated files.  \n\
     \t -h help  \n\
     \t -v Verbose. \n"

while getopts hacrC:S: c
 do
    case $c in
        b)  widthArg=$OPTARG;;
        S)  scenarios=$OPTARG;;
        C)  receiverClocks=$OPTARG;;
        r)  doReport=Yes;;
        a)  doAccumulateReport=Yes;;
        c)  doClean=Yes;;
        h)  echo  $USAGE; exit 2;;
        \?)  echo  $USAGE; exit 2;;
    esac
    done

shift `expr $OPTIND - 1`

archs=$*

######################################
# Tests:
######################################

if [ $doReport = "No" -a $doClean = "No" ]
then
    echo "One of the options -rc is required."
    echo $USAGE
    exit
fi

if [ "_$archs" = "_" ]
then archs=$allArchVersions
else
    for arch in $archs
    do
	if [ \( `expr "$allArchVersions" : ".*$arch"` -eq 0 \) \
	     -o \( \! -d $arch \) ]
	then
            echo "$arch is not a valid architecture."
            exit 2;
	fi
    done
fi

##########
# Processing -S argument:

if [ `expr $scenarios : "^[ABCDEZ,]*$"` -gt 0 ]
then
    scenarios=`echo $scenarios | sed -e 's/,/ /g'`
else
    echo "Incorrect argument for -S option."
    echo $USAGE; exit 2;
fi

##########
# Processing -C argument:

if [ $receiverClocks \!= "0" ]
then
    if [ `expr $receiverClocks : "^[,0-9]*$"` -gt 0 ]
    then
        receiverClocks=`echo $receiverClocks | awk '{alen=split($0, wa, ","); for (i in wa) print wa[i]; }'`
    else
        echo "Incorrect argument for -C option."
        echo $USAGE; exit 2;
    fi
fi

#############################################################################
if [ $doAccumulateReport = "No" ]
then 
    rm -rf $workingDir
    mkdir -p $workingDir

    ##################################################################
    wdtablef=$workingDir/$tablef
    echo "" > $wdtablef
    # Table heading:
    echo "% "  >$wdtablef
    echo "% $wdtablef generated by $0 " >>$wdtablef
    echo "% "  >>$wdtablef
    echo "\\\\begin{tabular}{lc|*{6}{r}}" >>$wdtablef
    echo "  & & & & & \multicolumn{3}{c}{Delay}\\\\\\\\" >>$wdtablef
    echo " Design & Scenario & \multicolumn{2}{c}{Clock period} & Throughput &  min & max & average \\\\\\\\" >>$wdtablef
    echo "  & & Sender & Receiver & [w/cy] & [cy] & [cy] & [cy] \\\\\\\\" >>$wdtablef
    echo "\hline" >>$wdtablef

    
else
    prevTablef=`basename $tablef .tex`-previous.tex
    mv $workingDir/$tablef $workingDir/$prevTablef
    echo "" > $workingDir/tablef
fi

#############################################################################
for arch in $archs
do
    for scen in  $scenarios
    do
	for clkr in $receiverClocks
	do
	    clks=10
	    echo "==========================================================="
	    echo "  Scenario $scen with half period clks = $clks, clkr = $clkr"
	    echo " "

	    make -C $arch -B scenario=$scen clkscenario=$clkr sim
	    vcdf=`make -s -C $arch scenario=$scen genvcdfile`       # generated vcd file
	    inf=`make -s -C $arch scenario=$scen gencominfile`      # generated by the simulation
	    outf=`make -s -C $arch scenario=$scen gencomoutfile`    # generated by the simulation

	    cp $arch/$vcdf $arch/$inf $arch/$outf $workingDir

	    cp analyseVcd.awk $workingDir
	    
	    cd $workingDir

	    #############################################################################
	    #
	    # We analys the vcd file to find
	    # - clock period,
	    # - Number of data generated (with respect to sender clock and the enable signal ens)
	    # - Overlap between sender and receiver enabled (ens and enr signals):

	    vcdResultLine=`./analyseVcd.awk $vcdf | egrep -v '^#'`  # analyse the vcd file and strip comment lines

	    clksPeriod=`echo $vcdResultLine | awk '{print $1}'`
	    clkrPeriod=`echo $vcdResultLine | awk '{print $2}'`
	    dinCnt=`echo $vcdResultLine | awk '{print $3}'`
	    ensDuration=`echo $vcdResultLine | awk '{print $4}'`
	    enOverlapNs=`echo $vcdResultLine | awk '{print $5}'`
	    enOverlapCy=`echo $vcdResultLine | awk '{print $6}'`
	    firstEns=`echo $vcdResultLine | awk '{print $7}'`

	    echo "Result of analyseVcd.awk:"
	    ./analyseVcd.awk $vcdf
	    
	    #############################################################################
	    # 
	    # Next, we compare the data generated by the testbench with the data received by the receiver.
	    # We compare two files to see
	    # (1) how much of the data in file1 is missing in file2, and
	    # (2) when the data of file1 has arrived in file2.

	    inf=commInputFile.txt      # generated by the simulation
	    outf=commOutputFile.txt    # generated by the simulation

	    # We strip the files from comments starting with #
	    # Also we exclude the data at 0 ns from input and output:
	    inwf=commInputFile-tmp.txt 
	    outwf=commOutputFile-tmp.txt 

	    egrep -v '^#' $inf | awk '$1!=0' > $inwf
	    egrep -v '^#' $outf | awk '$1!=0' > $outwf


	    trecf=timrec.txt  # The file with time records
	    echo "" > $trecf

	    tmpf=tmpf.txt
	    awk 'BEGIN { sntcnt=0; rcvdcnt=0; clksp='$clks'*2; clkrp='$clkr'*2; }
		 { tin=($1>'$firstEns') ? $1 : '$firstEns';
		   din=$3; sntcnt +=1;
		   found=0;
		   while ((getline < "'$outwf'") > 0)
			   { if ($3 == din) 
				{ found=1;
				  printf "%d:  %d  %d   %d\n", din, tin, $1, ($1-tin) >"'$trecf'"; 
				  break;
				}
			   }
		   close("'$outwf'");
		   # if (found==0) printf "Not found: %d\n", din;
		   # else rcvdcnt += 1;
		   if (found > 0) rcvdcnt += 1;
		 }
		  END { printf "#                                                            Throughput \n";
			printf "# Clock period     Data    data    Transmission period    (cy=sender period)\n";
			printf "# Sender Receiver  sent  received     [ns]     [cy]      [w/ns]   [w/cy]\n";
			Printf "--------------------------------------------------------------\n";
			printf "  %3d     %3d     %4d       %4d       %5d      %4d       %5.4f     %4.2f \n",
			       clksp, clkrp, sntcnt, rcvdcnt,
			       '$ensDuration', '$dinCnt', rcvdcnt/'$ensDuration', rcvdcnt/'$dinCnt'; }
		   ' \
		$inwf > $tmpf

	    tmpResultLine=`egrep  -v '^#' $tmpf`
	    clksp=`echo $tmpResultLine | awk '{print $1}'`
	    clkrp=`echo $tmpResultLine | awk '{print $2}'`
	    sntCnt=`echo $tmpResultLine | awk '{print $3}'`
	    rcvdCnt=`echo $tmpResultLine | awk '{print $4}'`
	    transPeriodNs=`echo $tmpResultLine | awk '{print $5}'`
	    transPeriodCy=`echo $tmpResultLine | awk '{print $6}'`
	    thruputNs=`echo $tmpResultLine | awk '{print $7}'`
	    thruputCy=`echo $tmpResultLine | awk '{print $8}'`

	    echo " "
	    echo "Result in $trecf:"
	    cat $trecf
	    echo " "
	    echo "Result of comparison between generated and received data:"
	    cat $tmpf
	    echo $tmpResultLine

	    
	    echo -n " $arch & $scen &  $clksp & $clkrp & $thruputCy " >>$tablef

	    
	    awk 'BEGIN {mind=0; maxd=0; avgd=0; dcnt=0; sumd=0; clksp=2*'$clks';}
	       { sumd += $4; dcnt += 1;
		 if (mind==0 || $4<mind) mind = $4;
		 if (maxd==0 || $4>maxd) maxd = $4; }
	 END { avgd=sumd/dcnt;
	       printf "#       Delays\n";
	       printf "#     min         max          average\n";
	       printf "#  [ns] [cy]  [ns] [cy]  [ns] [cy]\n";
               Printf "#--------------------------\n";
	       printf "  %4d %3.1f    %4d %3.1f     %4d %3.1f \n", mind, mind/clksp, maxd, maxd/clksp, avgd, avgd/clksp; }' \
		$trecf > $tmpf

	    tmpResultLine=`egrep  -v '^#' $tmpf`
	    mindns=`echo $tmpResultLine | awk '{print $1}'`
	    mindcy=`echo $tmpResultLine | awk '{print $2}'`
	    maxdns=`echo $tmpResultLine | awk '{print $3}'`
	    maxdcy=`echo $tmpResultLine | awk '{print $4}'`
	    avgdns=`echo $tmpResultLine | awk '{print $5}'`
	    avgdcy=`echo $tmpResultLine | awk '{print $6}'`

	    echo " "
	    echo "Final result:"
	    cat $tmpf
	    echo $tmpResultLine
	    
	    echo " & $mindcy & $maxdcy & $avgdcy \\\\\\\\[0ex]" >>$tablef

	    cd ..
	done
	
    done
    # echo " \hline \\\\\\\\" >>$tablef
    echo " \hline" >>$workingDir/$tablef
done

cd $workingDir

###################################
if [ $doAccumulateReport = "Yes" ]
then
    set -x
    tableBody=tmpTableBody.tex
    tableHead=tmpTableHead.tex
    tableTail=tmpTableTail.tex
    mergedBody=tmpTableMergedBody.tex
    
    awk '/^ .*((Sync)|(Async))/ {print }' \
	$prevTablef > $tableBody
    awk '/^ .*((Sync)|(Async))/ {exit }
    	    {print}' \
		$prevTablef > $tableHead
    awk '/^ .*((Sync)|(Async))/  { bodyseen=1; }
    	 !/^ .*((Sync)|(Async))/ { if (bodyseen) print}' \
		$prevTablef | uniq > $tableTail
    
    cat $tableBody $tablef | sort -k 1,2 -t \& > $mergedBody

    cat $tableHead > $tablef

    awk ' { if ($1 == prevfst) print;
            else { print " \\hline"; print; prevfst=$1; }}' \
		$mergedBody >> $tablef

    cat $tableTail >> $tablef
    
else
    
    echo "\\\\end{tabular}" >>$tablef
    echo " " >>$tablef
    echo "cy = sender clock period" >>$tablef

    echo " " >>$tablef
fi

#############################################################################
# process and display the table from the latex file:

tmptexf=tmptable.tex
tmptexf2=tmptable2.tex
tmppdff=tmptable.pdf

sed -e 's/Synchronous/Sync/' -e 's/Asynchronous/Async/' $tablef \
    | sed -e 's/^ *\\hline/\\hline/' \
    | uniq > $tmptexf2
mv $tmptexf2 $tablef

echo "\\\\documentclass[11pt]{article}" > $tmptexf
echo "\\usepackage{booktabs}" >> $tmptexf
echo "\\\\begin{document}" >> $tmptexf
sed -e 's/Synchronous/Sync/' -e 's/Asynchronous/Async/' $tablef \
    | sed -e 's/^ *\\hline/\\hline/' \
    | uniq >> $tmptexf
echo "\\\\end{document}" >> $tmptexf
pdflatex $tmptexf
xpdf $tmppdff &
sleep 2

cp $tablef ..

echo " "
echo " "
echo " Result file is $tablef which can be included in a latex source file."
exit;


# The following loop goes through the datafiles dataNNns.txt
# to find when the ready signals go 1:
for c in 4 6 8 10 12 14 16 18 19 20
do
    f=data${c}ns.txt
    mint=80
    maxt=$((80+4*c))
    echo "===  $c  80ns   ${maxt}ns"
    awk '{ if (p==0) p=$1; else {print ($1-p)/1000000; p=$1;}}' $f
done
