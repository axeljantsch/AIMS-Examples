# -*- mode: makefile -*-

.PHONY: helpc wave

# This makefile generates a report table with the help of a script and
# copies the resulting Latex file to the target directory.


# ----------------------------------
# Setup of variables:
# ----------------------------------

SHELL = /bin/sh

# ----------------------------------
# Verilog simulation:
# ----------------------------------
SimSrc := multiplierBeh-Pipelined-0.v

# We have one testbench:
SimTbn := $(SimSrc:.v=_tb.v)

vcdFiles :=   $(SimTbn:.v=.vcd)

SimMan := 
SimGen := $(vcdFiles)
SimRes = $(SimSrc) 

# Can be cleaned up:
SimCln = $(vcdFiles) $(SimTbn:.v=)

# ---------------------------------
# Yosys synthesis and P&R:
# ---------------------------------

SynSrc := $(SimSrc)

dotFiles := *.dot
tirepFiles := *.tirep
synDirs := Pipelined-*

SynGen := $(dotFiles)
SynRes := $(SynGen)
SynCln := $(SynGen) $(SynRes) $(dotfiles) $(tirepFiles)
SynDCln := $(synDirs)

# ---------------------------------
# Reporting:
# ---------------------------------

tableLP8Kcsv := multiplierBeh-LP8K.csv
tableLP8Ktex := multiplierBeh-LP8K.tex

RepRes := $(tableLP8Kcsv) $(tableLP8Ktex) 

RepCln := *.txt 

# Source files:
AllSrc := $(SimSrc) $(SimTbn)

# ---------------------------------
# Scripts and other files:
# ---------------------------------

# Script to compile and display the Latex table:
showLatexScript=showLatexFile.sh

# Script for displaying the table in various formats:
showTable=pptable.py 

RepSpt := $(showTable) $(showLatexScript)

synrepScript := mkFiguresAndTablesCh05.sh

SynSpt := $(synrepScript)


AllSpt := $(SynSpt) $(RepSpt)

# ---------------------------------
# Files to clean:
# ---------------------------------
AllCln := $(SimCln) $(SynCln) $(RepCln)
AllDCln := $(SynDCln)

# -----------------------------------------------------------------------------------------
#
# Interface variables to the main Makefile.
# The following variables are used by the main Makefile.
#
# -----------------------------------------------------------------------------------------

# Files to copy to the Latex production directories:
AllRes := $(SimRes) $(SynRes) $(RepRes)

# Files to copy to the Github repository:
src4GitFiles := $(AllSrc) Makefile MakefileComp

# -----------------------------------------------------------------------------------------
# End of interface variables.
# -----------------------------------------------------------------------------------------

# ---------------------------------
# Specific rules:
# ---------------------------------

simResult: $(vcdFiles)     ### Simulate

wave: simResult            ### View simulation waveforms
	@for f in $(vcdFiles); do gtkwave -S $(viewsigsTcl) $$f & done

# ---------------------------------
# Table generation:
# ---------------------------------

tableLP8K:                 ### Make a table for LP8K technology without pipelining
	for p in 0; \
	do rm -rf Pipelined-$$p; \
	   mkdir -p Pipelined-$$p; \
	   cp multiplierBeh-Pipelined-$${p}.v Pipelined-$${p};\
	   done; 
	$(ScriptDir)/$(synrepScript) -N multiplierBeh -yp -b 4,8,16,32 -T lp8k -P 0 -R -F 1-5,7;
	mv multiplierBeh-table.csv $(tableLP8Kcsv);
	mv multiplierBeh-textable.tex $(tableLP8Ktex);

repResult: tableLP8K   ### Generate the table for the Book


# ---------------------------------
# Yosys synthesis:
# ---------------------------------

synResult: $(dotFiles) ### Optimize and generate dot files

%.dot: %.v   
	stem=`basename $@ .dot`; \
	yosys -q -p "read_verilog $<; \
                  synth_ice40; opt -purge; \
                  show -notitle -format dot -prefix $${stem};"

%-synth.v: %.v  
	yosys -q -p "read_verilog $<; \
		synth_ice40; opt -purge; \
		write_verilog $@;"

%-lut.tex: %-synth.v  
	awk -v latex=1 -f lut2tt.awk < $< > $@

%.json: %.v
	yosys $(QFLAG) -p "read_verilog $<; opt; synth_ice40; write_json $@;"

helpc:


# =================================
# Generic rules:
# =================================

# ---------------------------------
# Verilog simulation:
# ---------------------------------
# We have two cases, one with separate testbench file and one without.
#
# Case 1: Separate testbench:
# We assume the file name convention:
#    FILE.v      ... source Verilog file
#    FILE_tb.v   ... testbench file
#    FILE_tb     ... simulatable file
#    FILE_tb.vcd ... value change dump file as a result of the simulation   
%_tb.vcd: %.v %_tb.v
	iverilog -o $*_tb $^
	vvp $*_tb

# Case 2: No separate testbench, just one verilog source file:
# We assume the file name convention:
#    FILE.v    ... source Verilog file
#    FILE      ... simulatable file
#    FILE.vcd  ... value change dump file as a result of the simulation   
%.vcd: %.v
	iverilog -o $* $^ $(SimSrc)
	vvp $*

%.json: %.v
	yosys $(QFLAG) -p "read_verilog $<; opt; synth_ice40; write_json $@;"

